import { PDFDocument, rgb, degrees, StandardFonts } from 'pdf-lib';
// Note: In a real environment, you might need 'file-saver' to save, 
// but we will use native URL.createObjectURL

export const mergePDFs = async (files: File[]): Promise<Uint8Array> => {
  const mergedPdf = await PDFDocument.create();
  
  for (const file of files) {
    const arrayBuffer = await file.arrayBuffer();
    const pdf = await PDFDocument.load(arrayBuffer);
    const copiedPages = await mergedPdf.copyPages(pdf, pdf.getPageIndices());
    copiedPages.forEach((page) => mergedPdf.addPage(page));
  }
  
  return await mergedPdf.save();
};

export const imagesToPDF = async (files: File[]): Promise<Uint8Array> => {
  const pdfDoc = await PDFDocument.create();

  for (const file of files) {
    const arrayBuffer = await file.arrayBuffer();
    let image;
    
    if (file.type === 'image/jpeg') {
      image = await pdfDoc.embedJpg(arrayBuffer);
    } else if (file.type === 'image/png') {
      image = await pdfDoc.embedPng(arrayBuffer);
    }

    if (image) {
      const page = pdfDoc.addPage([image.width, image.height]);
      page.drawImage(image, {
        x: 0,
        y: 0,
        width: image.width,
        height: image.height,
      });
    }
  }

  return await pdfDoc.save();
};

export const splitPDF = async (file: File): Promise<Uint8Array[]> => {
  const arrayBuffer = await file.arrayBuffer();
  const pdfDoc = await PDFDocument.load(arrayBuffer);
  const numberOfPages = pdfDoc.getPageCount();
  const splitFiles: Uint8Array[] = [];

  for (let i = 0; i < numberOfPages; i++) {
    const newPdf = await PDFDocument.create();
    const [page] = await newPdf.copyPages(pdfDoc, [i]);
    newPdf.addPage(page);
    splitFiles.push(await newPdf.save());
  }

  return splitFiles;
};

export const addWatermark = async (file: File, text: string): Promise<Uint8Array> => {
  const arrayBuffer = await file.arrayBuffer();
  const pdfDoc = await PDFDocument.load(arrayBuffer);
  const pages = pdfDoc.getPages();
  const font = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

  pages.forEach(page => {
    const { width, height } = page.getSize();
    const fontSize = 50;
    const textWidth = font.widthOfTextAtSize(text, fontSize);
    
    page.drawText(text, {
      x: width / 2 - textWidth / 2, 
      y: height / 2,
      size: fontSize,
      font: font,
      color: rgb(0.7, 0.7, 0.7),
      opacity: 0.4,
      rotate: degrees(45),
    });
  });

  return await pdfDoc.save();
};

export const removePages = async (file: File): Promise<Uint8Array> => {
  const arrayBuffer = await file.arrayBuffer();
  const pdfDoc = await PDFDocument.load(arrayBuffer);
  const pageCount = pdfDoc.getPageCount();
  
  // Logic: Remove the last page as a default action for this demo
  if (pageCount > 1) {
    pdfDoc.removePage(pageCount - 1);
  }
  
  return await pdfDoc.save();
};

export const reorderPages = async (file: File): Promise<Uint8Array> => {
  const arrayBuffer = await file.arrayBuffer();
  const pdfDoc = await PDFDocument.load(arrayBuffer);
  const pageCount = pdfDoc.getPageCount();
  
  const newPdf = await PDFDocument.create();
  // Logic: Reverse the order of pages
  const indices = Array.from({ length: pageCount }, (_, i) => i).reverse();
  const pages = await newPdf.copyPages(pdfDoc, indices);
  
  pages.forEach(p => newPdf.addPage(p));
  
  return await newPdf.save();
};

export const compressPDF = async (file: File): Promise<Uint8Array> => {
  const arrayBuffer = await file.arrayBuffer();
  const pdfDoc = await PDFDocument.load(arrayBuffer);
  // Re-saving with default options often cleans up the structure
  return await pdfDoc.save({ useObjectStreams: false }); 
};

// Simulated server-side tools
export const mockServerProcess = async (file: File, type: string): Promise<Uint8Array> => {
  // Create a VALID PDF placeholder instead of returning raw bytes
  // This ensures the user can open the file and see a result.
  const doc = await PDFDocument.create();
  const page = doc.addPage();
  const { width, height } = page.getSize();
  const font = await doc.embedFont(StandardFonts.HelveticaBold);
  const regularFont = await doc.embedFont(StandardFonts.Helvetica);
  
  page.drawText('AnyFile Conversion Success', {
    x: 50, y: height - 100, size: 24, font: font, color: rgb(0, 0, 0)
  });
  
  page.drawText(`Operation: ${type.toUpperCase()}`, {
    x: 50, y: height - 150, size: 16, font: regularFont
  });

  page.drawText(`Original Filename: ${file.name}`, {
    x: 50, y: height - 180, size: 14, font: regularFont
  });
  
  page.drawText('This file is a placeholder generated by the client-side demo.', {
    x: 50, y: height - 250, size: 12, font: regularFont, color: rgb(0.5, 0.5, 0.5)
  });
  
  page.drawText('In a production environment, this would contain your converted content.', {
    x: 50, y: height - 270, size: 12, font: regularFont, color: rgb(0.5, 0.5, 0.5)
  });

  return await doc.save();
};